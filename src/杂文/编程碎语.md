
# 大锁和小锁
线程锁、进程锁、分布式锁是常用的三种锁，它们的粒度越来越大，获取锁的难度也越来越大，导致系统的性能越来越低。锁越大，程序跑得越慢。当一个线程获取了分布式锁，则本机的其它线程、其它机器上的线程都无法获得这个锁了。当一个线程获得了进程锁，则本进程的其它线程、其它进程的线程都无法再次获得这个锁了。  
实现分布式锁是非常有用的，它能够让我们免于考虑线程锁，直接实现更完好的分布式支持。   
三种锁各有优劣，需要结合具体的场景具体分析。


# 有之以为利，无之以为用
面向对象编程，本身可以用面向过程编程实现。但是面向对象是一种思维方式。  
ResNet本身可以用全连接神经网络实现，但是经过约束、限制之后能够让它的功能更加明确。  
有之以为利，无之以为用。  
什么都说，等于什么都不说。信息太多，等于信息太少。  
约定大于配置，好的产品不是追求大而全，而是注意克制、注意保持简单。  
在开源界，只有好用、简单、能快速上手的工具才能够得到广泛使用。  

# 新语言
把代码文件夹组织的任务交给IDE去做，我只想写代码。一个工程项目就只有一个文件，这个文件里面只有类、方法、全局变量。如何组织函数的顺序交给UI去做。其实就是实现一个比较美观的outline。
程序员可以通过拖拽的方式设计UI，也可以通过拖拽的方式编程。但是为啥要用文本编辑器写代码，因为文本编辑器是最灵活、最简洁的，文本编辑器是最好的表单。

如果睡得比较晚，睡眠比较沉，可能比睡觉早效率更高。
世界上不是所有的问题都有巧妙完美的解法，问题通常是有参数的，人们想解决的问题是一大类问题而不是一个具有具体参数的问题。NP问题指的就是随着问题参数的线性变化，问题的复杂度指数变化。对于中国象棋而言，它就是一个具体的问题，其难度表现在空间复杂度和时间复杂度。

人生一世，能够用于专注高效思考的时间其实少之又少。年少时候，知识积累不够，思维能力发育不够；成熟之后，荷尔蒙作祟，整日想入非非；成家立业之后，俗务缠身，为名利所累；衰老之后，意兴阑珊，思维迟滞。


# 设计哲学
html、js、css三者应该如何组织？Controler、Dao应该如何组织？男人和女人应该如何组织？
无外乎两种方式：第一种是学校模式，把男生和女生作为第一层分类标准，然后再进一步对男生、女生分别进行分类；第二种是家庭模式，把男生和女生放在一起，然后存在很多个家庭。
学校模式以性别为第一要务，以文件类型为第一要务；家庭模式以业务为第一要务。
从Vue、React的组件来看，html、js、css应该优先按照业务逻辑，因为如果按照文件类型来划分，查找它们会变得很复杂，并且无法通过层次进行管理，组件是有层次的。
写代码时，数据定义、函数定义、类定义三者应该如何组织？像Vue那样，直接定义一个巨无霸的组件，所有的数据都放在data中，所有的methods都放在methods中，这样会导致这个巨无霸组件极其难以理解，这就是意大利面条式的代码。
优雅的代码一定是按照业务逻辑来划分的，而不是按照性别、文件类别这些公共知识来划分的。把家庭模式转化为学校模式是一件非常容易的事情。但是把学校模式转化为家庭模式则需要确定男女之间的对应关系才能实现。
所以，以业务逻辑为中心划分代码，以约定大于配置方式约定好每个家庭的组成。这在Vue里面被称为“关注点分离”。


# 语法糖还是IDE？
还记得匈牙利命名法吗？那时为了一眼辨别变量的类型，给标识符起名都加上类型前缀。现在有IDE，鼠标悬浮一下立马知道类型。
Python中，调用函数时，可以指明形参名称，如f(x=3,y=4)。在Java中无法指明形参名称，可是IntelliJ Idea现在已经可以自动给变量加上形参名称了，可读性很好。
对于lambda表达式，IntelliJ能够自动折叠代码，将可以用lambda表达式表达的函数自动用lambda表达式来表示。
于是余有叹焉。语法糖跟IDE是可以互相替换的。写代码时跟看代码时完全可以不一样，而不一定非得是一模一样的文本，依赖IDE并不是坏事。

# 过早的优化是万恶之源。
这句话听过好多次，却始终不理解它的真谛。
比如，写前端的时候，两个html有很多相似的东西，这相似的部分应不应该写在一个模板里面？
如果写在一个模板里面，就会束缚两个html的发展，因为二者是相互关联的。这两个html将来很有可能变得很不一样。
比如，写函数的时候，两个函数功能有很多相似的东西，是否应该将这两个函数合并为一个？如果合并为一个，将来需求变化，就会导致两个函数必须分开。
冗余能够更好地适应变化，分化能够更好地适应变化。

# 设计API
编写API、设计库的时候，要尽量减少学习者的成本。
比如，导出pdf时，设计成可以将html导出为pdf，itext库就是这样做的。
比如，设计html解析器时，用jquery的语法，pyquery就是这样做的。
世间事物有很多相似性，API的设计上也可以互相借鉴。尽量让各个库外表一样，尽量利用学习者的既有知识。


# 编程经验
* 代码提示是编程快感的重要来源
* 一个函数只做一件事，宁愿返回null，也不要超越本职
* 函数集中调用，群龙有首，才算清晰
* 相同的代码不一定非要合并，以后随着业务变迁，现在相同的代码日后可能不同，过早的优化是万恶之源，因为它限制了子孙的发展
* 要造轮子
  只有怀着造轮子的心情，才能产生找轮子的想法，才能对找到的轮子有深刻的理解。不要因为前人已经做过了就觉得造轮子没有意义。


# 为什么要把原理搞清楚？
* 出了问题能够钻进底层去理解、去解决，而不是总是浮在表面。对于那些几乎不会出问题的东西，没必要搞清楚原理，比如计算机硬件几乎不会出错，钻进去研究太深浪费时间
* 弄清楚那些发挥作用的部件。任何系统都可以进行分析，对它每个模块、每个步骤的作用都了然于胸才能在更精细的层面上应用这些部件。比如Redis，如果不了解原理，你只是学会了Redis本身，而了解了原理之后，你得到的就是一系列组件：各种数据结构、各种分布式机制。这些组件可以在其它地方得到应用。
* 为了再创造。这一点跟第2点有许多共通之处，当我们弄清楚了每个部件的具体作用，我们就能够分析出每个部件的缺点和优点，从而可以针对优缺点扬长避短制作出更加高效完美的部件。比如神经网络为何有效？如果我们搞清楚了有效算法的必备要素，我们就可以重新开创一套类似的体系。


# 细细的绳子
编程上的许多事物像
细细的绳子上挂着老大一团东西
一个大肚瓶的瓶口纤细非常，肚子里面却又大又圆
我的比喻是：
服务发现机制
在公司里，有各种各样的服务。服务这么多，给每个服务都分配一个域名显然是不合理的。那么就要自己建立一个标志符到IP的映射。


任何程序都不应该依赖IDE去提示错误，而应该凭程序员经验。弱类型语言最能体现出一个程序员对代码的掌控力，因为弱类型语言把自由交给了程序员。
任何程序的正确性都不应该完全依赖测试，因为测试是不可能穷尽所有情况的，逻辑却能。在ACM编程比赛中这一点体现的特别突出。



前端的配置应该是由服务端下发的，并且前端拉取服务端配置应该是在第一次加载时主动进行，不应该是懒加载的。因为前端也可能是移动端，移动端是不可能实时更新配置的，所以必须考虑把可以灵活变动的数据放在服务端。当设计某个API时，考虑一下如果加上移动端会怎样，不良设计自动就过滤掉了。

随便一种结构，不一定是神经网络，只要满足如下两点，就能够起到和神经网络一样的作用：
* 容量巨大
* 可以有效训练


编程不要追求套路和模板，编程是自由的。要追求新奇、追求暴力、追求简洁。


每一种通用编程语言都有函数，函数是表达逻辑的基本单元。函数的参数和返回值是函数最重要的特点。Python中允许多个返回值，实际上多个返回值会被打包成一个元组，返回值本质上还是单个返回值。Python中多个返回值机制本质上是元组的创建机制和元组的解构机制（如x,y=someTuple）。
函数参数的变化更为丰富：命名参数、变长参数、参数默认值。
变长参数可以使用数组解构来实现，命名参数可以使用字典解构来实现。
JavaScript有了解构语法，使得传参、返回值问题迎刃而解。这个设计可谓简洁巧妙。

好的应用都是随着时间推移不断完善的，而不是一蹴而就的。开发应用的过程是一个迭代的过程，只有看到当前的应用之后才会产生新的优化需求。应用就像一锅粥，需要慢慢去熬。
前端十分简单，确实最需要迭代的，只有先做出一版来，才知道缺陷在哪里，才能促进自己主动思考解决之道。
数据分析也是如此，只有先编一段程序才能发现数据特征，才能确定更好的方法。
迭代犹如人住房子，若是不住在里面，房子总会积满灰尘，若是常住里面，房子总会光洁如新。



伟大的程序都是丑陋的。要想高效就要无所不用其极，就要偏僻扭曲，就要适用范围狭窄，就要可读性差，就要难以理解。
然而，有的程序要解决的问题并不伟大，却滥用“制造伟大程序”的方法，导致代码矫揉造作、小题大做、画蛇添足。


让数据驱动UI，而不是让UI控制UI，每个UI组件之间都是独立的，每个UI组件都不互相影响。UI组件只能影响数据，并且UI组件只能受到数据的影响。明白这个道理，就能够做到“不乱”。每个UI组件都可以写成一个class，不同的UI组件都访问data。



git常用的命令何其少啊！可是git包含的命令却多得很。学了也是用不上。过度设计无处不在。
maven好还是gradle好。有人说gradle语法简介，并且可以像ant一样执行逻辑。我说：执行逻辑是很少用的，大部分情况下都是解决依赖问题，对于常用的逻辑maven都包含对应的插件。maven足矣。
做一件事，第一次完成之后就可以封存起来了，再进行摸索很容易沦为过度设计。
对于功能丰富与功能简陋又有一种哲学：功能简陋能够约束用户行为。例如Java减少了灵活性，降低了程序员的自由度，使程序员养成好习惯。简单是一种信仰。
做一件事情的途径是不唯一的，实现某个功能去做某件事可能还不如现有的途径简洁。



世界上的知识是无穷无尽的
如何描述斐波那契数列
方法一:给出一个列表来
方法二:告知`a[1]`,`a[2]`,再告知`a[n+1]=a[n]+a[n-1]`
方法二的好处是简洁,全面
方法一的优点是速度快,不需要计算就能很快知道`a[i]`

世间的知识也是如此
只需要知道`a[1]`,`a[2]`(原子知识)和自然法则(如何用原子知识推导出其他知识),就足以应付全部知识了
这其实也是一种压缩.
两个文件,一个记录了全部的情况,另一个文件记录了原子情况和组合规律.
信息的表达方式与文件压缩关系密切,压缩也是一种加密方式
任何信息都有一个压缩极限,香农的信息熵真的能够表达信息量吗?
信息只是客体,人的意志才是主体.没有主体,信息只是一堆无意义的符号.
当人眼不看光时,光与黑暗无异.
同一束光,对于不同的眼睛来说,亮度不一样
同一段文字,对于不同的大脑来说,含义不一样.有的人思绪延绵,从一滴水中看到了整个宇宙.
有的人所得即所见,对信息无所察觉.


黑名单与白名单的区别。当我把一个人加到黑名单之前，我会检查他是不是白名单里面的，如果是，那就不把他加到黑名单了。如果不是，那就加到黑名单里。白名单优先级比较高。


做出一样东西之后，一定要进行可视化展示。这样才能让别人快速理解你所做的工作，让别人快速了解一个系统所具有的功能。对于一个库，如果有可视化演示，人们就能很快掌握这个库的大致内容，远比看文档轻松快捷。



把计算任务放到前端能够非常有效地减轻后端压力，前端有很多个，这本身就是分布式计算。努力优化后端可能比较困难，换一种思路，把计算放到前端，问题可能会迎刃而解。


当选择某种技术时，看一下大厂是怎么做的，大厂在选择这项技术的时候必然是经过深思熟虑的。
比如markdown中如何显示公式，知乎上面的公式其实是图片。所以我们可以下定结论：用图片的方式很好。


编程的本质就是写短码,用有限表示无限.


# 为什么汉语编程不可行？
与其讨论编程语言，不如讨论数学语言。数学是符号的语言，它不属于英语，也不属于汉语，它就是一种人类共通的符号语言。
编程语言是描述算法的语言，它不是英语，只能说它借用了一些英语词汇作为关键词。

机器最重要的是常识，数字就是一种常识，是与生俱来的固有认知。
空间也是如此，数字和空间是推理的基础。
空间和数字正好对应几何和代数。


# 随意变化的题目
我曾经特别喜欢解决那些奇形怪状的问题。而许多问题只要变一下规则就会是另一个问题，这些奇形怪状的问题是无穷无尽的，如果沉浸其中，也是一种虚度光阴。但是，这些问题都很有趣味，很有探究性。像许多其他游戏一样，小玩怡情，大玩伤身。
比如：52张扑克牌为什么人们选择24点游戏，而不是其它点数游戏？这个问题就需要考虑随机选择四个数字，随机四则运算的情况下，哪个数字出现概率最高。
再比如：中国象棋如果一次可以走两步会怎样，会不会是先手必胜？
除了这种趣题，还有人热衷于考虑各种假设，比如如果牛顿活在现在会怎样？如果没有爱因斯坦会怎样？
这种问题杞人忧天，十分无聊，要远离这种“文科”的假设，适度思考“理科”的假设，多多把时间用在平时正常的学习任务上。
许多时候，人学习东西都是水过地皮湿。看电影、读小说、刷知乎这些行为都是极其相似的：无须过脑、看完就忘。适度放松可以，但是千万要把主要时间用来思考。


不要盲目相信库，设计库的也是人。库设计的未必合理，比如说java时间库，一开始是java.util.Date,那月份竟然是0是1月，1是2月，设计者竟然还是高司令（从源码中看到的），后来java也不好意思了，弄了一个Calendar，那叫一个烂哪，calendar.get()一大堆呀，Calendar.HOUR跟Calendar.HOUR_OF_DAY还不是一回事啊，你要是用Calendar.HOUR来获取时间，那么中午12：05就变成了00:05了，于是java的开源社区不干了，推出来了好几种处理事件的库，时间日期虽然简单，但应用起来至关重要万万马虎不得。java8终于引入了java.time，似乎java中的时间乱局到此结束了，与此同时，那些时间第三方库也该退休了。再比如说android的httpclient跟apache httpclient的恩怨情仇，那情节叫一个曲折呀。再比如说apache xmlrpc库，返回值始终是Object类型的，还得自己转换成javaBean，要是像fastjson那样直接转化成一个bean多好。再比如说apache beanutils库，所依赖的库是3.x的apache的collections库，而collections现在都变成了4.0了，包名弄得多了一点东西，log4j2.0的包名也是在log4j 1.x的基础上包名多了一点东西，非常不美观。apache的变Utils也很烂，转换的限制特别多，bean必须是public的。


有些技术文档老旧跟现在的代码不匹配，所以看文档不一定好，看官方样例更好。


如何检测自己是否学会了一个框架？一旦用了便再也离不开了，这就说明对这个框架真正掌握了。如果用框架有一种沉重感，总是感觉有人在要求自己使用框架，那说明不了解或者不喜欢这个框架。

约定大于配置，契约式编程规则，惯例优先原则。灵活未必是好事，让用户做许多无必要的犹豫。在很多种方法中选择一种方法，在很多条道路中选择一条道路，是一件费脑筋的事情。如果两种方法差异不大，那么就只给用户提供一种方法。好的产品要引导用户去果断选择，而不是提供许多功能相近的选择让人去思考到底用哪个。

笔算开平方的原理(10a+b)^2=100a^2+b^2+20ab,设M=(10a+b)^2,则M-100a^2=b*(20a+b).


凡事皆兴于简洁，毁于臃肿。不要追求不属于你的东西，做好分内之事。一个函数只做一件事，把这件事做好就够了。一个产品只做一件事，不要引入太多功能。一个框架，做着做着就添了许多鸡肋功能。发展是必要的，但已经完成预期目标之后，不能为了发展而发展一些无关轻重的产业。


实现一样东西跟设计一样东西是两个过程，不要同时做这两件事，所以编程时，先设计好接口，再设计具体实现。


# 用电脑写作和用本子写作
用电脑写作最大的优势就是：方便检索，方便更改。用本子写作就缺少这两大优势。



工作经验：
* 一切凭实验说话，切忌想当然、不要说空话。
* 不盲目否定别人的观点，没有调查就没有发言权，要鼓励别人去验证自己的想法，并提供力所能及的帮助。
* 大领导应该有大格局，能够包容一些短时间内没有产出的研究；小领导应该有小计较，要研究核心问题而不要在一些细枝末节处徘徊。


现在的广告邮件大多以“面试”作为题目的开头，因为面试的邮件可能在邮箱的白名单里。但时日一久，“面试”二字反倒成了垃圾邮件的重要特征，因为包含这两字直接判为垃圾邮件的准确率很高。可想而知，再过一段时间，正常的面试邮件大都不会包含“面试”二字了。再过一段时间，垃圾邮件醒悟过来之后，也不带“面试”二字了。一切回归平常，就像最初什么也没发生一样。然而有暗蕴生机，垃圾邮件又发现了新的白名单词语。一切机器学习算法在这个过程中表现得如此脆弱、死板、无力，反倒是简单直接的逻辑药到病除。


写博客的好处有很多,第一,写博客是我在讲,是知识输出的过程,这个过程督促自己去主动思考;第二,写博客可以查阅,看自己的东西远远比看别人的东西明白的快;第三,写博客可以看见自己的脚印,从而更有动力往前走.


成长的过程就是改变偏见的过程。过去我以为学习一样东西必须把官网文档看一遍才能开始动手自己编。现在我认为：“Just Do It”是最好的法则。想要知道如何做一件事的最好方法就是直接去做这件事，而不是系统地阅读做这件事的教程。当你阅读教程时，因为你没有做过，所以无法理解教程。一旦你对于这件事有了一定理解，再去看教程就会融会贯通豁然开朗。

坚守精简原则,用大部分时间去改善核心功能,淡化周边扩展功能
shell脚本指令众多,却有许多并无卵用
不要好高骛远,不要求全责备
用到再查,用到再学

论拼子
我子多敌人子少，拼子可以让敌人彻底丧失战斗力。
敌人子多我子少，拼子会让自己失去仅有的本钱，而发挥好的话，用这些本钱很有可能翻盘。


读网页文章的启示：
当我们在读网页时，手都是在动的
我们想一直滚动鼠标滚轮，我们想一直不停地翻页
我们想眼睛不停的换行
我们不想一动不动，那样容易走神
并且容易让我们感到自己看的太慢，以至于没有成就感
网页上如果字太密集，会让人很难受
应该稀疏点，网页又不要钱

写网页文章不要写错别字。
如果连基本的语文都没学好，遇到不太确定的字应该查一下；如果是不小心打出错别字，那说明习惯不好。要记住：错别字多就是习惯问题。打字时一边打一遍注意着是否打错字费不了多少力气，反而读文章时发现错别字会很不爽，不仅会产生对作者水平的质疑从而影响对文章的吸收，也会让人潜意识产生防范心理（告诉自己选择性吸收）。


恐怖谷理论说:机器人的似人度达到95%以上后,稍微有点不像人,就会令人恐惧不安厌恶之


